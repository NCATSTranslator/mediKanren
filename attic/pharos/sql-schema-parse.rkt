#lang racket/base
(require
  "mk.rkt"
  "mk-parse.rkt"
  )

;; Parse SQL schema
(define delimiters '("," ")") )
(define delimiter (one-of delimiters))

(define (sq name) (seq "\'" (single name) "\'"))
(define (dq name) (seq "\"" (single name) "\""))
(define (bq name) (seq "`" (single name) "`"))

(define (paren p items)
  (define (comma-prefixed item) (seq "," (p item)))
  (fresh/p (first rest)
    (== `(,first . ,rest) items)
    (seq "(" (p first) ((many* comma-prefixed) rest) ")")))

(define (field-type type)
  (or/p ((remember1 (one-of '("integer" "text" "timestamp" "date"))) type)
        (fresh/p (m n)
          (== "decimal" type)
          (seq "decimal" "(" (single m) "," (single n) ")"))
        (fresh/p (_)
          (== "text" type)
          (seq "varchar" "(" (single _) ")"))
        (fresh/p (_)
          (== "text" type)
          (seq "char" "(" (single _) ")"))))

(define (field/primary-key name type)
  (seq (bq name) (field-type type)
       (skip*-until (append '("PRIMARY") delimiters))
       "PRIMARY" "KEY" (skip*-until delimiters)))

(define (field/non-primary-key name type)
  (seq (bq name) (field-type type)
       (skip* (none-of (append '("PRIMARY" "KEY") delimiters)))
       (peek delimiter)))

(define (primary-key names)
  (seq "PRIMARY" "KEY" (paren bq names) (peek delimiter)))

(define (unique names) (seq "UNIQUE" (paren bq names) (peek delimiter)))

(define (foreign-key fk-name local-names table foreign-names)
  (seq "CONSTRAINT" (bq fk-name) "FOREIGN" "KEY" (paren bq local-names)
       "REFERENCES" (bq table) (paren bq foreign-names)
       (skip*-until delimiters)))

(define (create-table table-name body*)
  (define (field-or-cx datum)
    (or/p (fresh/p (name type)
            (== `(field primary-key ,name ,type) datum)
            (field/primary-key name type))
          (fresh/p (name type)
            (== `(field #f ,name ,type) datum)
            (field/non-primary-key name type))
          (fresh/p (names)
            (== `(primary-key ,names) datum)
            (primary-key names))
          (fresh/p (names)
            (== `(unique ,names) datum)
            (unique names))
          (fresh/p (fk-name locals table foreigns)
            (== `(foreign-key ,fk-name ,locals ,table ,foreigns) datum)
            (foreign-key fk-name locals table foreigns))))
  (seq "CREATE" "TABLE" (bq table-name) (paren field-or-cx body*) ";"))

(define (create-index index-name table-name field-names)
  (seq "CREATE" "INDEX" (dq index-name) "ON"
       (dq table-name) (paren bq field-names) ";"))

(define (schema body*)
  (define (table-or-index datum)
    (or/p (fresh/p (name tbody)
            (== `(table ,name ,tbody) datum)
            (create-table name tbody))
          (fresh/p (name tname fnames)
            (== `(index ,name ,tname ,fnames) datum)
            (create-index name tname fnames))))
  (seq ((many* table-or-index) body*) end))

(define (entries->schema entry*)
  (define (entry->table entry)
    (define name (cadr entry))
    (let loop ((field* '()) (unique* '()) (foreign* '()) (attr* (caddr entry)))
      (if (null? attr*)
        `(,name (field . ,(reverse field*))
                (unique . ,(reverse unique*))
                (foreign . ,(reverse foreign*)))
        (let* ((attr (car attr*)) (tag (car attr)) (attr* (cdr attr*)))
          (cond ((eqv? 'field tag)
                 (define primary? (cadr attr))
                 (define name (caddr attr))
                 (define type (cadddr attr))
                 (define field `(,name ,type))
                 (loop (cons field field*)
                       (if primary? (cons (list name) unique*) unique*)
                       foreign* attr*))
                ((or (eqv? 'unique tag) (eqv? 'primary-key tag))
                 (define names (cadr attr))
                 (loop field* (cons names unique*) foreign* attr*))
                ((eqv? 'foreign-key tag)
                 (define name (cadr attr))
                 (define local (caddr attr))
                 (define table (cadddr attr))
                 (define remote (cadddr (cdr attr)))
                 (define foreign `(,name ,local ,table ,remote))
                 (loop field* unique* (cons foreign foreign*) attr*))
                (else (error "invalid attribute:" attr)))))))
  (define (entry->index entry)
    (define name (cadr entry))
    (define table (caddr entry))
    (define fields (cadddr entry))
    `(,name ,table ,fields))
  (let loop ((table* '()) (index* '()) (entry* entry*))
    (if (null? entry*) `((tables . ,(reverse table*))
                         (indexes . ,(reverse index*)))
      (let ((entry (car entry*)) (entry* (cdr entry*)))
        (cond ((eqv? 'table (car entry))
               (loop (cons (entry->table entry) table*) index* entry*))
              ((eqv? 'index (car entry))
               (loop table* (cons (entry->index entry) index*) entry*))
              (else (error "invalid schema entry:" entry)))))))

(define (tokens->entries tokens)
  (define results (run* (body*) ((schema body*) tokens '())))
  (when (= 0 (length results)) (error "failed to parse"))
  (when (< 1 (length results))
    (error "ambiguous parse: count=" (length results)))
  (car results))

(write (entries->schema (tokens->entries (read))))
